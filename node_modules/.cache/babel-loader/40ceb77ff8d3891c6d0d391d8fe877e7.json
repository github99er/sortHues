{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\Owner\\\\Desktop\\\\AlgoMazeOff\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"C:\\\\Users\\\\Owner\\\\Desktop\\\\AlgoMazeOff\\\\src\\\\maze\\\\PathfindingVisualizer\\\\PathfindingVisualizer.jsx\";\nimport React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\nimport Navbar from \"../Navbar\";\nimport './PathfindingVisualizer.css';\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n\n    this.getInitialGrid = () => {\n      const grid = [];\n\n      for (let row = 0; row < 20; row++) {\n        const currentRow = [];\n\n        for (let col = 0; col < 50; col++) {\n          currentRow.push(this.createNode(col, row));\n        }\n\n        grid.push(currentRow);\n      }\n\n      return grid;\n    };\n\n    this.createNode = (col, row) => {\n      console.log(this.state.grid);\n      return {\n        col,\n        row,\n        isStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n        isFinish: row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\n        distance: Infinity,\n        isVisited: false,\n        isWall: false,\n        previousNode: null\n      };\n    };\n\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      START_NODE_ROW: Math.floor(Math.random() * Math.floor(20)),\n      START_NODE_COL: Math.floor(Math.random() * Math.floor(50)),\n      FINISH_NODE_ROW: Math.floor(Math.random() * Math.floor(20)),\n      FINISH_NODE_COL: Math.floor(Math.random() * Math.floor(50))\n    };\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({\n      grid\n    });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({\n      grid: newGrid,\n      mouseIsPressed: true\n    });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({\n      grid: newGrid\n    });\n  }\n\n  handleMouseUp() {\n    this.setState({\n      mouseIsPressed: false\n    });\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-shortest-path';\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const grid = this.state.grid;\n    const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n    const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  refreshPage() {\n    window.location.reload(false);\n  }\n\n  refreshGrid() {\n    const grid = this.getInitialGrid();\n    this.setState({\n      grid\n    });\n    const START_NODE_ROW = Math.floor(Math.random() * Math.floor(20));\n    const START_NODE_COL = Math.floor(Math.random() * Math.floor(50));\n    const FINISH_NODE_ROW = Math.floor(Math.random() * Math.floor(20));\n    const FINISH_NODE_COL = Math.floor(Math.random() * Math.floor(50));\n    this.setState({\n      START_NODE_ROW,\n      START_NODE_COL,\n      FINISH_NODE_ROW,\n      FINISH_NODE_COL\n    });\n  }\n\n  render() {\n    const _this$state = this.state,\n          grid = _this$state.grid,\n          mouseIsPressed = _this$state.mouseIsPressed;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 9\n      }\n    }, grid.map((row, rowIdx) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: rowIdx,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 129,\n          columnNumber: 15\n        }\n      }, row.map((node, nodeIdx) => {\n        const row = node.row,\n              col = node.col,\n              isFinish = node.isFinish,\n              isStart = node.isStart,\n              isWall = node.isWall;\n        return /*#__PURE__*/React.createElement(Node, {\n          key: nodeIdx,\n          col: col,\n          isFinish: isFinish,\n          isStart: isStart,\n          isWall: isWall,\n          mouseIsPressed: mouseIsPressed,\n          onMouseDown: (row, col) => this.handleMouseDown(row, col),\n          onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n          onMouseUp: () => this.handleMouseUp(),\n          row: row,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 133,\n            columnNumber: 21\n          }\n        });\n      }));\n    })), /*#__PURE__*/React.createElement(Navbar, {\n      search: () => this.visualizeDijkstra(),\n      refresh: () => this.refreshGrid(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 152,\n        columnNumber: 9\n      }\n    }));\n  }\n\n}\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  const newNode = _objectSpread(_objectSpread({}, node), {}, {\n    isWall: !node.isWall\n  });\n\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","map":{"version":3,"sources":["C:/Users/Owner/Desktop/AlgoMazeOff/src/maze/PathfindingVisualizer/PathfindingVisualizer.jsx"],"names":["React","Component","Node","dijkstra","getNodesInShortestPathOrder","Navbar","PathfindingVisualizer","constructor","getInitialGrid","grid","row","currentRow","col","push","createNode","console","log","state","isStart","START_NODE_ROW","START_NODE_COL","isFinish","FINISH_NODE_ROW","FINISH_NODE_COL","distance","Infinity","isVisited","isWall","previousNode","mouseIsPressed","Math","floor","random","componentDidMount","setState","handleMouseDown","newGrid","getNewGridWithWallToggled","handleMouseEnter","handleMouseUp","animateDijkstra","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","animateShortestPath","node","document","getElementById","className","visualizeDijkstra","startNode","finishNode","refreshPage","window","location","reload","refreshGrid","render","map","rowIdx","nodeIdx","slice","newNode"],"mappings":"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","sourcesContent":["import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\r\nimport Navbar from \"../Navbar\"\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\n\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      START_NODE_ROW: Math.floor(Math.random() * Math.floor(20)),\r\n      START_NODE_COL: Math.floor(Math.random() * Math.floor(50)),\r\n      FINISH_NODE_ROW: Math.floor(Math.random() * Math.floor(20)),\r\n      FINISH_NODE_COL: Math.floor(Math.random() * Math.floor(50)),\r\n\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({grid: newGrid, mouseIsPressed: true});\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({grid: newGrid});\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({mouseIsPressed: false});\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-shortest-path';\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    const {grid} = this.state;\r\n    const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n    const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  refreshPage() {\r\n    window.location.reload(false);\r\n  }\r\n\r\n  refreshGrid(){\r\n    const grid = this.getInitialGrid();\r\n    this.setState({grid});\r\n    const START_NODE_ROW = Math.floor(Math.random() * Math.floor(20));\r\n    const START_NODE_COL = Math.floor(Math.random() * Math.floor(50));\r\n    const FINISH_NODE_ROW = Math.floor(Math.random() * Math.floor(20));\r\n    const FINISH_NODE_COL = Math.floor(Math.random() * Math.floor(50));\r\n    this.setState({START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL});\r\n    \r\n  }\r\n\r\n  getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 50; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n  \r\n  createNode = (col, row) => {\r\n    console.log(this.state.grid)\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish: row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  };\r\n  \r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n\r\n    return (\r\n      <>\r\n       \r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {row, col, isFinish, isStart, isWall} = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      row={row}></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        <Navbar search={() => this.visualizeDijkstra()} refresh={() => this.refreshGrid()} />\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}